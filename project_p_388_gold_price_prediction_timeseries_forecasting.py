# -*- coding: utf-8 -*-
"""Project -P-388- Gold price prediction_TimeSeries - Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xG7TuQgzhWd4T0k7Zcso5Jq2lxL3kF7I

# TIME SERIES GOLD PRICE FORECASTING
### 1: Data Preparation and Exploration
#### - 1. Data Loading
#### - 2. Initial Exploration (Plotting Time Series)
#### - 3. Data Preprocessing

### 2: ARIMA Model Building
#### - 1. Parameter Selection for ARIMA
#### - 2. Model Fitting
#### - 3. Diagnostics
#### - 4. Forecasting

### 3: Exponential Smoothing
#### - 1. Model Selection
#### - 2. Parameter Optimization
#### - 3. Model Fitting and Forecasting

### 4: Evaluation Metrics & Comparison
#### - 1. Compute Error Metrics
#### - 2. Model Comparison
#### - 3. Conclusion

# 1: Data Preparation and Exploration
"""

# 1. Data Loading
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load dataset
df = pd.read_csv('Gold_data.csv')

# Display basic info
print(df.info())
print(df.head())

# 2. Initial Exploration (Plotting Time Series)
# Plotting the time series
plt.plot(df['price']) # Changed 'Price' to 'price'
plt.title('Gold Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price')
plt.grid(True)
plt.show()

"""### Explanation:
#### - Visualizing the data helps identify trends, seasonality, or anomalies.
"""

# 3. Data Preprocessing
# Check for missing values
print(df.isnull().sum())

# Fill or drop missing values
df = df.fillna(method='ffill')

# Ensure the index is in datetime format
df.index = pd.to_datetime(df.index)

"""# 2: ARIMA Model Building
### 1. Parameter Selection for ARIMA
### 2. Model Fitting
### 3. Diagnostics
### 4. Forecasting

"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
import statsmodels.api as sm

# 1. Parameter Selection for ARIMA
# Plot ACF and PACF
plot_acf(df['price'])
plot_pacf(df['price'])
plt.show()

# 2. Model Fitting
# Based on plots, choose p=5, d=1, q=0 as starting point (can adjust after testing)
# Fit ARIMA model (you can change p,d,q based on ACF/PACF)
model_arima = ARIMA(df['price'], order=(5,1,0))
model_arima_fit = model_arima.fit()
print(model_arima_fit.summary())

#3. Diagnostics
# Diagnostic plots
model_arima_fit.plot_diagnostics(figsize=(10, 6))
plt.show()

# 4. Forecasting
forecast_arima = model_arima_fit.forecast(steps=30)  # Forecasting next 30 time steps

# Plot Forecast
plt.figure(figsize=(12,5))
plt.plot(df['price'], label='Actual')
plt.plot(forecast_arima.index, forecast_arima, label='Forecast (ARIMA)', color='red')
plt.title('ARIMA Forecast')
plt.legend()
plt.grid(True)
plt.show()

"""# 3: Exponential Smoothing
### 1. Model Selection
### 2. Parameter Optimization
### 3. Model Fitting and Forecasting

"""

from statsmodels.tsa.holtwinters import ExponentialSmoothing

# 1. Model Selection
# Holt’s Linear Trend Model
model_holt = ExponentialSmoothing(df['price'], trend='add', seasonal=None)
model_holt_fit = model_holt.fit()

# Forecast
forecast_holt = model_holt_fit.forecast(30)

# 2. Parameter Optimization
# Plot
plt.figure(figsize=(12,5))
plt.plot(df['price'], label='Actual')
plt.plot(forecast_holt.index, forecast_holt, label='Forecast (Holt)', color='green')
plt.title('Holt Linear Forecast')
plt.legend()
plt.grid(True)
plt.show()

# 3. Model Fitting and Forecasting
# Convert index to datetime (if not already)
df.index = pd.to_datetime(df.index)

# Fit Holt’s Linear Trend Model
holt_model = ExponentialSmoothing(df['price'], trend='add', seasonal=None).fit()

# Forecast next 30 days
holt_forecast = holt_model.forecast(30)

# Forecast dates
forecast_dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=30)

# Save forecast for comparison
forecast_df = pd.DataFrame({
    # Changed model_fit to model_arima_fit to match the variable name from the ARIMA section
    'ARIMA': model_arima_fit.forecast(steps=30).values,
    'Holt': holt_forecast.values
}, index=forecast_dates)

# Display forecast comparison
forecast_df.head()

"""# 4: Evaluation Metrics & Comparison
### 1. Compute Error Metrics
### 2. Model Comparison
### 3. Conclusion
"""

# 1. Compute Error Metrics
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

# Create test set
train = df.iloc[:-30]
test = df.iloc[-30:]

# Refit ARIMA and Holt on train
model_arima = ARIMA(train['price'], order=(5,1,0)).fit()
model_holt = ExponentialSmoothing(train['price'], trend='add').fit()

# Forecast
forecast_arima = model_arima.forecast(steps=30)
forecast_holt = model_holt.forecast(30)

# 2. Model Comparison
# Evaluation metrics
def evaluate(true, pred):
    mae = mean_absolute_error(true, pred)
    rmse = np.sqrt(mean_squared_error(true, pred))
    mape = np.mean(np.abs((true - pred) / true)) * 100
    return mae, rmse, mape

mae_arima, rmse_arima, mape_arima = evaluate(test['price'], forecast_arima)
mae_holt, rmse_holt, mape_holt = evaluate(test['price'], forecast_holt)

print(f"ARIMA -> MAE: {mae_arima:.2f}, RMSE: {rmse_arima:.2f}, MAPE: {mape_arima:.2f}%")
print(f"Holt  -> MAE: {mae_holt:.2f}, RMSE: {rmse_holt:.2f}, MAPE: {mape_holt:.2f}%")

"""#  Visualization: Forecasts vs Actuals"""

import matplotlib.pyplot as plt

# Create a DataFrame to align the results
comparison_df = pd.DataFrame({
    # Changed 'pricee' to 'price' and used the correct forecast variable names
    'Actual': test['price'].values,
    'ARIMA Forecast': forecast_arima.values,
    'Holt Forecast': forecast_holt.values
}, index=test.index)

# Plot the results
plt.figure(figsize=(14, 6))
plt.plot(comparison_df['Actual'], label='Actual Price', color='black', linewidth=2)
plt.plot(comparison_df['ARIMA Forecast'], label='ARIMA Forecast', linestyle='--', color='blue')
plt.plot(comparison_df['Holt Forecast'], label='Holt Forecast', linestyle='--', color='green')
plt.title('Forecast Comparison: ARIMA vs Holt’s Linear Trend')
plt.xlabel('Date')
plt.ylabel('price')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""# 3. Conclusion:
### The time series forecasting was performed using both ARIMA and Exponential Smoothing (Holt’s Linear) models.
### The dataset was carefully preprocessed to ensure clean and continuous data for modeling.
### ARIMA involved selecting optimal (p,d,q) parameters using ACF and PACF plots, and it was found to capture short-term trends and patterns well.
### Holt’s Linear Trend model, being a form of Exponential Smoothing, was used to model the trend component and delivered a comparatively smoother forecast.
### The models were evaluated on a 30-day out-of-sample test set using MAE (Mean Absolute Error), RMSE (Root Mean Square Error), and MAPE (Mean Absolute Percentage Error).

### Lower values of MAE, RMSE, and MAPE indicate better forecasting performance.
### Visual comparison of the forecasted vs. actual values showed that the model whose forecast line is closest to actual is likely to be more reliable.
### Based on both visual inspection and quantitative metrics, the final model should be selected.
"""

